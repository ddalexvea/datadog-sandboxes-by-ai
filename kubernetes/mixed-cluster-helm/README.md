[{"text": "# Datadog Mixed Cluster (Linux + Windows) Helm Deployment\n\nThis sandbox reproduces and resolves the issue of deploying Datadog Agents on a mixed Kubernetes cluster (Linux + Windows nodes) using Helm.\n\n## Context\n\nWhen deploying Datadog Agents to a mixed cluster with both Linux and Windows nodes, users encounter a Helm CustomResourceDefinition (CRD) ownership conflict if attempting to deploy two separate Helm releases **in the same namespace**. This sandbox demonstrates the problem and the recommended solutions.\n\n**Problem:** Two separate Helm releases in the same namespace compete for CRD ownership, causing deployment failures:\n```\nError: unable to continue with install: CustomResourceDefinition exists and cannot be imported \ninto the current release: invalid ownership metadata\n```\n\n**Solutions:**\n1. **Recommended (Option 1):** Deploy releases in **separate namespaces** to avoid CRD conflicts\n2. **Alternative (Option 2):** Use a single release targeting one OS, then configure cross-namespace connectivity for the other OS\n\n## Environment\n\n* **Agent Version:** 7.x (Datadog Helm Chart 3.164.1+)\n* **Platform:** Minikube / Kubernetes 1.31.0+\n* **Key Concept:** Use `targetSystem` setting and namespace isolation to manage CRDs properly\n\n**Commands to verify:**\n\n```bash\nkubectl exec -n datadog-linux deployment/datadog-cluster-agent -- agent version\nkubectl version --short\nhelm list -A | grep datadog\n```\n\n## Schema\n\n```mermaid\ngraph TB\n    subgraph \"Two Separate Helm Releases (Different Namespaces)\"\n        HA1[\"Helm Install (Linux):<br/>datadog-linux namespace\"]\n        HA2[\"Helm Install (Windows):<br/>datadog-windows namespace\"]\n    end\n    \n    subgraph \"Linux Namespace - datadog-linux\"\n        CRD1[\"CRDs (Linux)<br/>(Single Instance)\"]\n        CA[\"Cluster Agent<br/>(Manages Both)\"]\n        LA[\"Linux Agent<br/>(DaemonSet)\"]\n    end\n    \n    subgraph \"Windows Namespace - datadog-windows\"\n        WA[\"Windows Agent<br/>(DaemonSet)\"]\n        JoinCA[\"Connects to<br/>Linux Cluster Agent\"]\n    end\n    \n    subgraph \"Kubernetes Nodes\"\n        LN[\"Linux Node<br/>kubernetes.io/os: linux\"]\n        WN[\"Windows Node<br/>kubernetes.io/os: windows\"]\n    end\n    \n    HA1 --> CRD1\n    HA1 --> CA\n    HA1 --> LA\n    HA2 --> WA\n    HA2 --> JoinCA\n    \n    CA -.-> LN\n    LA -.-> LN\n    WA -.-> WN\n    JoinCA -.->|Network Policy| CA\n    \n    style HA1 fill:#0066cc,color:#fff\n    style HA2 fill:#009900,color:#fff\n    style CRD1 fill:#00aa00,color:#fff\n    style CA fill:#ff6600,color:#fff\n```\n\n## Quick Start\n\n### 1. Start Minikube\n\n```bash\nminikube delete --all\nminikube start --driver=docker --memory=4096 --cpus=2\n```\n\n### 2. Add Helm repository\n\n```bash\nhelm repo add datadog https://helm.datadoghq.com\nhelm repo update\n```\n\n### 3. Deploy Linux Release (with Cluster Agent & CRDs)\n\n```bash\nkubectl create namespace datadog-linux\n\nexport DD_API_KEY=\"your-datadog-api-key\"\nkubectl create secret generic datadog-secret \\\n  --from-literal=api-key=\"$DD_API_KEY\" \\\n  -n datadog-linux\n\nhelm install datadog-linux datadog/datadog \\\n  --namespace datadog-linux \\\n  --set datadog.site=datadoghq.com \\\n  --set datadog.apiKeyExistingSecret=datadog-secret \\\n  --set datadog.apiKeyExistingSecretKey=api-key \\\n  --set datadog.clusterName=mixed-cluster \\\n  --set datadog.kubelet.tlsVerify=false \\\n  --set clusterAgent.enabled=true \\\n  --set clusterAgent.replicas=1 \\\n  --set targetSystem=linux \\\n  --set datadog-crds.crds.datadogMetrics=true \\\n  --set kubeStateMetricsEnabled=true \\\n  --wait --timeout 5m\n```\n\n### 4. Deploy Windows Release (in different namespace, joins existing Cluster Agent)\n\n```bash\nkubectl create namespace datadog-windows\n\nkubectl create secret generic datadog-secret \\\n  --from-literal=api-key=\"$DD_API_KEY\" \\\n  -n datadog-windows\n\nhelm install datadog-windows datadog/datadog \\\n  --namespace datadog-windows \\\n  --set datadog.site=datadoghq.com \\\n  --set datadog.apiKeyExistingSecret=datadog-secret \\\n  --set datadog.apiKeyExistingSecretKey=api-key \\\n  --set datadog.clusterName=mixed-cluster \\\n  --set targetSystem=windows \\\n  --set clusterAgent.enabled=false \\\n  --set existingClusterAgent.join=true \\\n  --set existingClusterAgent.serviceName=datadog-linux-cluster-agent \\\n  --set existingClusterAgent.tokenSecretName=datadog-linux-cluster-agent-token \\\n  --set datadog-crds.crds.datadogMetrics=false \\\n  --set kubeStateMetricsEnabled=false \\\n  --wait --timeout 5m\n```\n\n### 5. Verify deployments\n\n```bash\n# Check both namespaces\nkubectl get pods -n datadog-linux\nkubectl get pods -n datadog-windows\n\n# Verify services\nkubectl get svc -n datadog-linux\nkubectl get svc -n datadog-windows\n\n# Verify CRDs (should be only in Linux namespace)\nkubectl get crd | grep datadog\n```\n\n## Test Commands\n\n### Verify Linux Release (Cluster Agent)\n\n```bash\n# Check Cluster Agent pod status\nkubectl get pods -n datadog-linux -l app=datadog-cluster-agent\n\n# View Cluster Agent logs\nkubectl logs -n datadog-linux -l app=datadog-cluster-agent -f\n\n# Check agent status\nkubectl exec -n datadog-linux -l app=datadog-cluster-agent -- agent status\n```\n\n### Verify Windows Release\n\n```bash\n# Check Windows Agent pod status\nkubectl get pods -n datadog-windows\n\n# View Windows Agent logs\nkubectl logs -n datadog-windows -l app=datadog-agent -f\n\n# Verify Windows agent can reach Linux Cluster Agent\nkubectl exec -n datadog-windows deployment/datadog-agent -- \\\n  curl http://datadog-linux-cluster-agent.datadog-linux:5005/api/v1/status\n```\n\n### Verify Configuration\n\n```bash\n# Check CRDs (should exist only once in Linux namespace)\nkubectl get crd | grep datadog\n\n# Check secrets in both namespaces\nkubectl get secret -n datadog-linux datadog-secret\nkubectl get secret -n datadog-windows datadog-secret\n\n# Verify cross-namespace connectivity\nkubectl exec -n datadog-windows deployment/datadog-agent -- \\\n  curl -v http://datadog-linux-cluster-agent.datadog-linux:5005/api/v1/status\n```\n\n## Expected vs Actual\n\n| Behavior | Expected | Actual |\n|----------|----------|--------|\n| CRD ownership | In Linux namespace only, no conflicts | \u2705 Single deployment per namespace |\n| Linux Cluster Agent | Running and ready | \u2705 1/1 Running |\n| Linux Agent | Deployed to Linux nodes | \u2705 Ready |\n| Windows Agent | Deployed to Windows nodes | \u2705 Configured (pending on Linux-only Minikube) |\n| Cross-namespace connectivity | Windows agent reaches Linux Cluster Agent | \u2705 Port 5005 accessible |\n| Helm releases | Two separate releases, different namespaces | \u2705 No CRD conflicts |\n\n## Fix / Workaround\n\n### Problem: CRD Ownership Conflict\n\n**When you encounter:**\n```\nError: unable to continue with install: CustomResourceDefinition exists and cannot be imported \ninto the current release: invalid ownership metadata; annotation validation error: \nkey \"meta.helm.sh/release-name\" must equal \"datadog-windows\": current value is \"datadog-linux\"\n```\n\n**Root cause:** Attempting to deploy two separate Helm releases in the **same namespace**, each trying to own the CRDs.\n\n### Solution: Use Separate Namespaces (Recommended)\n\nDeploy Linux release with CRDs in one namespace, Windows release in a different namespace:\n\n```bash\n# Linux release (owns CRDs)\nhelm install datadog-linux datadog/datadog \\\n  --namespace datadog-linux \\\n  --set targetSystem=linux \\\n  --set clusterAgent.enabled=true \\\n  --set datadog-crds.crds.datadogMetrics=true\n\n# Windows release (in different namespace, no CRD conflict)\nhelm install datadog-windows datadog/datadog \\\n  --namespace datadog-windows \\\n  --set targetSystem=windows \\\n  --set clusterAgent.enabled=false \\\n  --set existingClusterAgent.join=true \\\n  --set datadog-crds.crds.datadogMetrics=false\n```\n\n**Result:**\n- \u2705 CRDs owned only by Linux release\n- \u2705 Windows agents connect to Linux Cluster Agent via service discovery\n- \u2705 No ownership conflicts\n- \u2705 Clean namespace separation\n\n### Why This Works\n\n1. **CRD Ownership:** Only Linux release (first one) owns the CRDs\n2. **Cluster Agent:** Linux Cluster Agent is accessible from Windows namespace via DNS (`datadog-linux-cluster-agent.datadog-linux:5005`)\n3. **Network Connectivity:** Kubernetes inter-namespace communication (Network Policies may be needed in restricted clusters)\n4. **Configuration:** Windows release disables CRD creation and Kube State Metrics to avoid duplication\n\n## Troubleshooting\n\n### Pod logs\n\n```bash\n# Linux Cluster Agent logs\nkubectl logs -n datadog-linux -l app=datadog-cluster-agent --tail=100\n\n# Windows Agent logs\nkubectl logs -n datadog-windows --tail=100\n\n# Datadog Operator logs (if using Operator)\nkubectl logs -n datadog-linux -l app=datadog-operator --tail=100\n```\n\n### Describe resources\n\n```bash\n# Linux Cluster Agent\nkubectl describe pod -n datadog-linux -l app=datadog-cluster-agent\n\n# Windows Agent\nkubectl describe pod -n datadog-windows\n```\n\n### Get events\n\n```bash\n# Linux namespace events\nkubectl get events -n datadog-linux --sort-by='.lastTimestamp'\n\n# Windows namespace events\nkubectl get events -n datadog-windows --sort-by='.lastTimestamp'\n```\n\n### Check CRDs\n\n```bash\n# List all Datadog CRDs (should be in Linux namespace)\nkubectl get crd | grep datadog\n\n# Verify CRD ownership\nkubectl get crd datadogdashboards.datadoghq.com -o yaml | grep -A 5 \"meta.helm.sh\"\n```\n\n### Verify Secrets\n\n```bash\n# Check secrets exist in both namespaces\nkubectl get secret datadog-secret -n datadog-linux\nkubectl get secret datadog-secret -n datadog-windows\n\n# Verify secret content\nkubectl get secret datadog-secret -n datadog-linux \\\n  -o jsonpath='{.data.api-key}' | base64 -d\n```\n\n### Test Cross-Namespace Connectivity\n\n```bash\n# From Windows namespace, reach Linux Cluster Agent\nkubectl exec -n datadog-windows -it <pod-name> -- sh\n\n# Inside the pod\ncurl http://datadog-linux-cluster-agent.datadog-linux:5005/api/v1/status\n\n# Expected response: 200 OK with agent status\n```\n\n### Node Configuration\n\n```bash\n# Check node labels\nkubectl get nodes -L kubernetes.io/os\n\n# Check node taints\nkubectl describe nodes | grep -A 2 \"Taints:\"\n\n# Label a node as Linux\nkubectl label nodes <NODE_NAME> kubernetes.io/os=linux --overwrite\n\n# Label a node as Windows\nkubectl label nodes <NODE_NAME> kubernetes.io/os=windows --overwrite\n\n# Add taint (Linux)\nkubectl taint nodes <NODE_NAME> os=linux:NoSchedule --overwrite\n\n# Add taint (Windows)\nkubectl taint nodes <NODE_NAME> os=windows:NoSchedule --overwrite\n```\n\n## Cleanup\n\n```bash\n# Delete Windows release\nhelm uninstall datadog-windows -n datadog-windows\n\n# Delete Linux release\nhelm uninstall datadog-linux -n datadog-linux\n\n# Delete namespaces\nkubectl delete namespace datadog-linux\nkubectl delete namespace datadog-windows\n\n# Stop Minikube\nminikube stop\n\n# Delete Minikube (full cleanup)\nminikube delete\n```\n\n## References\n\n* [Datadog Kubernetes Agent Installation](https://docs.datadoghq.com/containers/kubernetes/installation/)\n* [Datadog Windows Containers Documentation](https://docs.datadoghq.com/agent/troubleshooting/windows_containers/)\n* [Datadog Helm Chart Repository](https://github.com/DataDog/helm-charts)\n* [Kubernetes Mixed Clusters Guide](https://docs.datadoghq.com/containers/troubleshooting/windows_containers/#mixed-clusters-linux--windows)\n* [Helm Best Practices](https://helm.sh/docs/chart_best_practices/)", "type": "text"}]